import {JsDoc, JsDocTagDoc} from "../../doc_node/mod.ts";

const RE_NLS = /\r?\n/g;
const RE_MD_ESCAPE = /[`[{<*_~\\#]/g;
const RE_MD_ESCAPE_LINK_TEXT = /[`[{<*_~\\#\]]/g;
const RE_MD_ENCODE_URI = /[^\w\-$.';\/?:@&=+,#]+/g;
const RE_MD_BLOCKQUOTE = /^>*/gm;
const RE_BAD_SHELL_CHAR = /[^\w%+\-.\/:=@]/;
const RE_PARSE_HEADER_ID = /([ ]|[\p{Letter}\p{Number}_]+)|\\.|<\/?\w+(?:[^"'>]+|"[^"]*"|'[^']*')*>|\[([^\]\r\n]+)\]\([^)\r\n]+\)/sug;

const encoder = new TextEncoder;

/**	Escape special characters in the given text, so if it will be inserted to a markdown document, the text will appear literally.
	The resulting string doesn't contain new-line characters.
 **/
export function mdEscape(text: string)
{	return text.replace(RE_MD_ESCAPE, c => `\\${c}`).replace(RE_NLS, '<br>');
}

function mdEscapeLinkText(text: string)
{	return text.replace(RE_MD_ESCAPE_LINK_TEXT, c => `\\${c}`).replace(RE_NLS, '<br>');
}

function mdEncodeURI(text: string)
{	return text.replace
	(	RE_MD_ENCODE_URI,
		c =>
		{	const buf = encoder.encode(c);
			let t = '';
			for (const b of buf)
			{	t += b<=0xF ? '%0'+b.toString(16) : '%'+b.toString(16);
			}
			return t;
		}
	);
}

/**	Construct markdown link from it's visible text and href by enclosing and escaping it's parts as needed.
	The link can be in regular font or monospace.
 **/
export function mdLink(text: string, href: string, isMonospace=false)
{	text = mdEscapeLinkText(text);
	href = mdEncodeURI(href);
	return isMonospace ? `[\`${text}\`](${href})` : `[${text}](${href})`;
}

/**	Converts markdown code to blockquote by prepending `>` to each text line.
 **/
export function mdBlockquote(text: string)
{	return !text ? '' : text.replace(RE_MD_BLOCKQUOTE, m => m ? m+'>' : '> ') + '\n\n';
}

/**	Returns true if the given node has attached doc-comment that contains `@`deprecated tag.
 **/
export function isDeprecated(node: object | {jsDoc?: JsDoc}): JsDocTagDoc|undefined
{	const tags = ('jsDoc' in node ? node.jsDoc : undefined)?.tags;
	if (tags)
	{	for (const t of tags)
		{	if (t.kind == 'deprecated')
			{	return t;
			}
		}
	}
}

/**	Enclose text in apostrophs and/or add backslashes if the text contains characters that must be escaped in bash command line.
 **/
export function escapeShellArg(arg: string)
{	return RE_BAD_SHELL_CHAR.test(arg) ? "'" + arg.replaceAll("'", "'\\''") + "'" : arg;
}

/**	For given markdown header line (text after 1 or more `#` signs)
	this function returns header html id attribute that would be generated by github and similar markdown processors.
 **/
export function parseHeaderId(headerLine: string)
{	let headerId = '';
	if (headerLine)
	{	RE_PARSE_HEADER_ID.lastIndex = 0;
		let m;
		while ((m = RE_PARSE_HEADER_ID.exec(headerLine)))
		{	if (m[1])
			{	headerId += m[1]==' ' ? '-' : m[1].toLocaleLowerCase();
			}
			else if (m[2])
			{	const pos = RE_PARSE_HEADER_ID.lastIndex;
				headerId += parseHeaderId(m[2]);
				RE_PARSE_HEADER_ID.lastIndex = pos;
			}
		}
	}
	return headerId;
}
